<!doctype html>
<html lang="en" class="no-js">

<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://html5-templates.com/" />
<title>Static Analysis Based Partitioning</title>
<link href="css/bootstrap.min.css" rel="stylesheet">
<link href="css/sticky-menu.css" rel="stylesheet">
</head>
<style>
/* this is for bar-graph*/
.bar {
	fill: steelblue;
}

/* everything below is for circle-packing */
.node {
	cursor: pointer;
}

.node:hover {
	stroke: #000;
	stroke-width: 1.5px;
}

.node--leaf {
	fill: white;
}

.label {
	font: 11px "Helvetica Neue", Helvetica, Arial, sans-serif;
	text-anchor: middle;
	text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;
}

.label, .node--root, .node--leaf {
	pointer-events: none;
}

/* bundling */
.nodeHigh {
	font: 10px sans-serif;
	font-weight: bold;
}

.node {
	font: 10px sans-serif;
}

.link {
	stroke: steelblue;
	stroke-opacity: 0.5;
	fill: none;
	pointer-events: none;
}
</style>

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container">
			<div class="navbar-header page-scroll">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target=".navbar-ex1-collapse">
					<span class="sr-only">Toggle menu</span> <span class="icon-bar"></span>
					<span class="icon-bar"></span> <span class="icon-bar"></span>
				</button>
				<a class="navbar-brand page-scroll" href="#page-top">About</a>
			</div>

			<div class="collapse navbar-collapse navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					<li class="hidden"><a class="page-scroll" href="#page-top"></a>
					</li>
					<li><a class="page-scroll" href="#meta">Meta</a></li>
					<li><a class="page-scroll" href="#partition">Recommended
							Natural Seams / Partition</a></li>
					<li><a class="page-scroll" href="#cohesioncoupling">Cohesion
							and Coupling</a></li>
				</ul>
			</div>
			<!-- .navbar-collapse -->
		</div>
		<!-- .container -->
	</nav>
	<!-- Welcome   -->
	<section id="welcome" class="welcome-section">
		<div class="container">
			<div class="row">
				<div class="col-lg-12">
					<h1>Library Framework API usage based paritioning</h1>
					<p>While implementing business functionalities, we leverage
						multiple propreitary and open source library frameworks and APIs
						in the applications. Analysis of usage of such APIs in the
						applications can provide insights on naturally occuring
						functionality boundaries.</p>
					<p>In this approach, we understand the usage of APIs in the
						application using static code analysis. Further we apply multiple
						unsupervised clustering approaches using this information to
						identify naturally occuring partitions. We further refine these
						partitions using metrics like cohesion and coupling, to recommend
						the final set of candidate micro services / partitions of the
						monlith application.</p>
					<img src="img/method.png" width="900" height="400">
					<p>&nbsp;</p>
					<a class="btn btn-primary page-scroll" href="#meta">Click To
						Scroll Down!</a>
				</div>
			</div>
		</div>
	</section>

	<!-- Meta -->
	<section id="meta" class="about-section">
		<div class="container">
			<div class="row">
				<div id="bar-graph" class="col-lg-12">
					<h1>Meta Information About Monolith Application</h1>
				</div>
			</div>
		</div>
	</section>

	<!-- Partition -->
	<section id="partition" class="whatwedo-section">
		<div class="container">
			<div class="row">
				<div id="cluster-graph" class="col-lg-6">
					<h3>Recommended partitions of monolith application using API
						Usage information</h3>
				</div>
				<div id="affinity-graph" class="col-lg-6">
					<h3>Recommended partitions of monolith application using
						Artifact Determination</h3>
				</div>
			</div>
		</div>
	</section>

	<!-- Partition -->
	<section id="cohesioncoupling" class="whatwedo-section">
		<div class="container">
			<div class="row">
				<div id="cohesion-all" class="col-lg-6">
					<h3>Cohesion And Coupling for API Usage Clusters</h3>
				</div>
				<div id="cohesion-affinity" class="col-lg-6">
					<h3>Cohesion And Coupling for Artifact based Clusters</h3>
				</div>
			</div>
		</div>
	</section>

	<!-- Comparison
	<section id="comparison" class="contact-section">
		<div class="container">
			<div class="row">
				<div class="col-lg-12">
				<h1>Comparison with  manual approach</h1>
					<div id="carouselExampleIndicators" class="carousel slide"
						data-ride="carousel">
						<ol class="carousel-indicators">
							<li data-target="#carouselExampleIndicators" data-slide-to="0"
								class="active"></li>
							<li data-target="#carouselExampleIndicators" data-slide-to="1"></li>
							<li data-target="#carouselExampleIndicators" data-slide-to="2"></li>
						</ol>
						<div class="carousel-inner">
							<div class="item active">
								<img src="img/method.png" alt="First slide" >
								<div class="carousel-caption d-md-block">
									<h5>First Image</h5>
								</div>
							</div>
							<div class="item">
								<img src="img/method.png" alt="Second slide" >
								<div class="carousel-caption d-md-block">
									<h5>Second Image</h5>
								</div>
							</div>
							<div class="item">
								<img src="img/method.png" alt="Third slide" >
								<div class="carousel-caption d-md-block">
									<h5>Third Image</h5>
								</div>
							</div>
						</div>
						<a class="carousel-control-prev" href="#carouselExampleIndicators"
							role="button" data-slide="prev"> <span
							class="carousel-control-prev-icon" aria-hidden="true"></span> <span
							class="sr-only">Previous</span>
						</a> <a class="carousel-control-next"
							href="#carouselExampleIndicators" role="button" data-slide="next">
							<span class="carousel-control-next-icon" aria-hidden="true"></span>
							<span class="sr-only">Next</span>
						</a>
					</div>
				</div>
			</div>
		</div>
	</section> -->

	<a id="back2Top" title="Back to top" href="#">&#10148;</a>

	<!-- jQuery -->
	<script src="js/jquery.js"></script>

	<!-- Bootstrap Core JavaScript -->
	<script src="js/bootstrap.min.js"></script>

	<!-- Scrolling Nav JavaScript -->
	<script src="js/jquery.easing.min.js"></script>
	<script src="js/sticky-menu.js"></script>

	<!-- D3-->
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<!-- bar data -->
	<script>
        
            // set the dimensions and margins of the graph
            var margin = {top: 20, right: 20, bottom: 30, left: 40},
                width = 960 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;
            
            // set the ranges
            var x = d3.scaleBand()
                      .range([0, width])
                      .padding(0.1);
            var y = d3.scaleLinear()
                      .range([height, 0]);
                      
            // append the svg object to the body of the page
            // append a 'group' element to 'svg'
            // moves the 'group' element to the top left margin
            var svg1 = d3.select("#bar-graph").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr("transform", 
                      "translate(" + margin.left + "," + margin.top + ")");
            
            // get the data
            d3.json("data/bar-data.json", function(error, data) {
              if (error) throw error;
              data = data.apiUsageStats;
              
              // format the data
              data.forEach(function(d) {
                d.usedAPIs = +d.usedAPIs;
              });
            
              // Scale the range of the data in the domains
              x.domain(data.map(function(d) { return d.jarName; }));
              y.domain([0, d3.max(data, function(d) { return d.usedAPIs; })]);
            
              // append the rectangles for the bar chart
              svg1.selectAll(".bar")
                  .data(data)
                .enter().append("rect")
                  .attr("class", "bar")
                  .attr("x", function(d) { return x(d.jarName); })
                  .attr("width", x.bandwidth())
                  .attr("y", function(d) { return y(d.usedAPIs); })
                  .attr("height", function(d) { return height - y(d.usedAPIs); });
            
              // add the x Axis
              svg1.append("g")
                  .attr("transform", "translate(0," + height + ")")
                  .call(d3.axisBottom(x)).selectAll("text").attr("y", 0)
             	 .attr("x", 9)
             	 .attr("dy", ".35em")
             	 .attr("transform", "rotate(-90)")
             	 .style("text-anchor", "start");
            
              // add the y Axis
              svg1.append("g")
                  .call(d3.axisLeft(y));
            
            });
            
            </script>

	<!-- Circle Packing Code -->
	<script>

        var svg = d3.select("#cluster-graph").append("svg").attr("width", 600).attr("height", 600),
            margin = 20,
            diameter = +svg.attr("width"),
            g = svg.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

        var color = d3.scaleLinear()
            .domain([-1, 5])
            .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
            .interpolate(d3.interpolateHcl);

        var pack = d3.pack()
            .size([diameter - margin, diameter - margin])
            .padding(2);

        d3.json("data/clusterall.json" , function (error, root) {
            if (error) throw error;

            root = d3.hierarchy(root)
                .sum(function (d) { return d.size; })
                .sort(function (a, b) { return b.value - a.value; });

            var focus = root,
                nodes = pack(root).descendants(),
                view;

            var circle = g.selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("class", function (d) { return d.parent ? d.children ? "node" : "node node--leaf" : "node node--root"; })
                .style("fill", function (d) { return d.children ? color(d.depth) : null; })
                .on("click", function (d) { if (focus !== d) zoom(d), d3.event.stopPropagation(); });

            var text = g.selectAll("text")
                .data(nodes)
                .enter().append("text")
                .attr("class", "label")
                .style("fill-opacity", function (d) { return d.parent === root ? 1 : 0; })
                .style("display", function (d) { return d.parent === root ? "inline" : "none"; })
                .text(function (d) { return d.data.name; });

            var node = g.selectAll("circle,text");

            svg
                .style("background", color(-1))
                .on("click", function () { zoom(root); });

            zoomTo([root.x, root.y, root.r * 2 + margin]);

            function zoom(d) {
                var focus0 = focus; focus = d;

                var transition = d3.transition()
                    .duration(d3.event.altKey ? 7500 : 750)
                    .tween("zoom", function (d) {
                        var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
                        return function (t) { zoomTo(i(t)); };
                    });

                transition.selectAll("text")
                    .filter(function (d) { return d.parent === focus || this.style.display === "inline"; })
                    .style("fill-opacity", function (d) { return d.parent === focus ? 1 : 0; })
                    .on("start", function (d) { if (d.parent === focus) this.style.display = "inline"; })
                    .on("end", function (d) { if (d.parent !== focus) this.style.display = "none"; });
            }

            function zoomTo(v) {
                var k = diameter / v[2]; view = v;
                node.attr("transform", function (d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
                circle.attr("r", function (d) { return d.r * k; });
            }
        });

    </script>
	<!-- Affinity Packing Code -->
	<script>

        var svg3 = d3.select("#affinity-graph").append("svg").attr("width", 600).attr("height", 600),
            margin = 20,
            diameter = +svg3.attr("width"),
            g2 = svg3.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

        var color1 = d3.scaleLinear()
            .domain([-1, 5])
            .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
            .interpolate(d3.interpolateHcl);

        var pack1 = d3.pack()
            .size([diameter - margin, diameter - margin])
            .padding(2);

        d3.json("data/cluster-affinity.json" , function (error, root) {
            if (error) throw error;

            root = d3.hierarchy(root)
                .sum(function (d) { return d.size; })
                .sort(function (a, b) { return b.value - a.value; });

            var focus = root,
                nodes = pack1(root).descendants(),
                view;

            var circle2 = g2.selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("class", function (d) { return d.parent ? d.children ? "node" : "node node--leaf" : "node node--root"; })
                .style("fill", function (d) { return d.children ? color1(d.depth) : null; })
                .on("click", function (d) { if (focus !== d) zoom(d), d3.event.stopPropagation(); });

            var text2 = g2.selectAll("text")
                .data(nodes)
                .enter().append("text")
                .attr("class", "label")
                .style("fill-opacity", function (d) { return d.parent === root ? 1 : 0; })
                .style("display", function (d) { return d.parent === root ? "inline" : "none"; })
                .text(function (d) { return d.data.name; });

            var node2 = g2.selectAll("circle,text");

            svg3
                .style("background", color(-1))
                .on("click", function () { zoom(root); });

            zoomTo([root.x, root.y, root.r * 2 + margin]);

            function zoom(d) {
                var focus0 = focus; focus = d;

                var transition = d3.transition()
                    .duration(d3.event.altKey ? 7500 : 750)
                    .tween("zoom", function (d) {
                        var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
                        return function (t) { zoomTo(i(t)); };
                    });

                transition.selectAll("text")
                    .filter(function (d) { return d.parent === focus || this.style.display === "inline"; })
                    .style("fill-opacity", function (d) { return d.parent === focus ? 1 : 0; })
                    .on("start", function (d) { if (d.parent === focus) this.style.display = "inline"; })
                    .on("end", function (d) { if (d.parent !== focus) this.style.display = "none"; });
            }

            function zoomTo(v) {
                var k = diameter / v[2]; view = v;
                node2.attr("transform", function (d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
                circle2.attr("r", function (d) { return d.r * k; });
            }
        });

    </script>
	<!--  for bundling -->
	<script>

			var diameter1 = 600,
			    radius = diameter1 / 2,
			    innerRadius = radius - 120;
			
			var cluster = d3.cluster()
			    .size([360, innerRadius]);
			
			var line = d3.radialLine()
			    .curve(d3.curveBundle.beta(0.85))
			    .radius(function(d) { return d.y; })
			    .angle(function(d) { return d.x / 180 * Math.PI; });
			
			var svg4 = d3.select("#cohesion-all").append("svg")
			    .attr("width", diameter1)
			    .attr("height", diameter1)
			  .append("g")
			    .attr("transform", "translate(" + radius + "," + radius + ")");

			var link = svg4.append("g").selectAll(".link"),
			    node = svg4.append("g").selectAll(".node");
			
			d3.json("data/cohesion-all.json", function(error, classes) {
			  if (error) throw error;
			
			  var root = packageHierarchy(classes)
			      .sum(function(d) { return d.size; });
			
			  cluster(root);
			
			  link = link
			    .data(packageImports(root.leaves()))
			    .enter().append("path")
			      .each(function(d) { d.source = d[0], d.target = d[d.length - 1]; })
			      .attr("class", "link")
			      .attr("d", line);
			
			  node = node
			    .data(root.leaves())
			    .enter().append("text")
			      .attr("class", function(d){ return d.data.coupling ? "nodeHigh" : "node"})
			      .attr("dy", "0.31em")
			      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)"); })
			      .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			      .text(function(d) { return d.data.key; });
			});

			// Lazily construct the package hierarchy from class names.
			function packageHierarchy(classes) {
			  var map = {};
			
			  function find(name, data) {
			    var node = map[name], i;
			    if (!node) {
			      node = map[name] = data || {name: name, children: []};
			      if (name.length) {
			        node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
			        node.parent.children.push(node);
			        node.key = name.substring(i + 1);
			      }
			    }
			    return node;
			  }
			
			  classes.forEach(function(d) {
			    find(d.name, d);
			  });
			
			  return d3.hierarchy(map[""]);
			}
			
			// Return a list of imports for the given array of nodes.
			function packageImports(nodes) {
			  var map = {},
			      imports = [];
			
			  // Compute a map from name to node.
			  nodes.forEach(function(d) {
			    map[d.data.name] = d;
			  });
			
			  // For each import, construct a link from the source to target node.
			  nodes.forEach(function(d) {
			    if (d.data.imports) d.data.imports.forEach(function(i) {
			      imports.push(map[d.data.name].path(map[i]));
			    });
			  });
			
			  return imports;
			}

</script>
<!--  for bundling -->
	<script>

			var diameter2 = 600,
			    radius2 = diameter2 / 2,
			    innerRadius2 = radius2 - 120;
			
			var cluster1 = d3.cluster()
			    .size([360, innerRadius2]);
			
			var line1 = d3.radialLine()
			    .curve(d3.curveBundle.beta(0.85))
			    .radius(function(d) { return d.y; })
			    .angle(function(d) { return d.x / 180 * Math.PI; });
			
			var svg5 = d3.select("#cohesion-affinity").append("svg")
			    .attr("width", diameter2)
			    .attr("height", diameter2)
			  .append("g")
			    .attr("transform", "translate(" + radius2 + "," + radius2 + ")");

			var link1 = svg5.append("g").selectAll(".link"),
			    node1 = svg5.append("g").selectAll(".node");
			
			d3.json("data/cohesion-affinity.json", function(error, classes) {
			  if (error) throw error;
			
			  var root = packageHierarchy(classes)
			      .sum(function(d) { return d.size; });
			
			  cluster(root);
			
			  link = link1
			    .data(packageImports(root.leaves()))
			    .enter().append("path")
			      .each(function(d) { d.source = d[0], d.target = d[d.length - 1]; })
			      .attr("class", "link")
			      .attr("d", line1);
			
			  node = node1
			    .data(root.leaves())
			    .enter().append("text")
			      .attr("class", function(d){ return d.data.coupling ? "nodeHigh" : "node"})
			      .attr("dy", "0.31em")
			      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)"); })
			      .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			      .text(function(d) { return d.data.key; });
			});

			// Lazily construct the package hierarchy from class names.
			function packageHierarchy(classes) {
			  var map = {};
			
			  function find(name, data) {
			    var node = map[name], i;
			    if (!node) {
			      node = map[name] = data || {name: name, children: []};
			      if (name.length) {
			        node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
			        node.parent.children.push(node);
			        node.key = name.substring(i + 1);
			      }
			    }
			    return node;
			  }
			
			  classes.forEach(function(d) {
			    find(d.name, d);
			  });
			
			  return d3.hierarchy(map[""]);
			}
			
			// Return a list of imports for the given array of nodes.
			function packageImports(nodes) {
			  var map = {},
			      imports = [];
			
			  // Compute a map from name to node.
			  nodes.forEach(function(d) {
			    map[d.data.name] = d;
			  });
			
			  // For each import, construct a link from the source to target node.
			  nodes.forEach(function(d) {
			    if (d.data.imports) d.data.imports.forEach(function(i) {
			      imports.push(map[d.data.name].path(map[i]));
			    });
			  });
			
			  return imports;
			}

</script> 

</body>

</html>